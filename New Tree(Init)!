#include <iostream>
using namespace std;
#include <string>
/*用顺序队列已经实现，试用链队
下面为链队代码
*/
typedef struct QNode
{
	int data;
	QNode *next;
}QNode, *QueuePtr;

typedef struct
{
	QueuePtr front;
	QueuePtr rear;
}LinkQueue;

void InitQueue(LinkQueue &Q)
{
	Q.front = Q.rear = new QNode;
	Q.front->next = NULL;
}
void EnQueue(LinkQueue &Q, int e)
{
	QueuePtr p;
	p = new QNode;
	p->data = e;
	p->next = NULL;
	Q.rear->next = p;
	Q.rear = p;
}
void InitBiTree(BiTree &T)
{
	T = NULL;
}
int DeQueue(LinkQueue &Q)
{
	QueuePtr p;
	if (Q.front = Q.rear)
	{
		return 0;
	}
	p = Q.front->next;
	cout << p->data;
	Q.front->next = p->next;
	if (Q.rear = p)
	{
		Q.rear = Q.front;
	}
	delete p;
	return 1;
}


typedef struct BiTNode{

	int data;

	BiTNode *lchild, *rchild;

}BiTNode, *BiTree;



void DestroyBiTree(BiTree &T)
{
	if (T)
	{
		DestroyBiTree(T->lchild);
		DestroyBiTree(T->rchild);
		delete T;
	}
}
void CreateBiTree(BiTree &T)//输入data为0，则代表不存在。
{
	int a;
	cin >> a;
	if (a == 0)
	{
		T = NULL;
	}
	else
	{
		T = new BiTNode;
		CreateBiTree(T->lchild);
		CreateBiTree(T->rchild);
		T->data = a;
	}
}
void InOrderTraverse(BiTree &T)
{
	if (T)
	{
		InOrderTraverse(T->lchild);

		cout << T->data << endl;

		InOrderTraverse(T->rchild);
	}

}
void PostOrderTraverse(BiTree &T)
{
	if (T)
	{
		PostOrderTraverse(T->lchild);

		PostOrderTraverse(T->rchild);

		cout << T->data << endl;
	}

}
void PreOrderTraverse(BiTree &T)
{
	if (T)
	{
		cout << T->data << endl;

		PreOrderTraverse(T->lchild);

		PreOrderTraverse(T->rchild);

	}

}


void LevelorderTraverse(BiTree &T)
{
	BiTNode *p[50];
	p[0] = T;
	int front = 0;
	int rear = 1;
	while (front<rear)
	{
		if (p[front])
		{
			cout << p[front]->data << ' ';

			p[rear++] = p[front]->lchild;

			p[rear++] = p[front]->rchild;

		}
			front++;
		
	}
}




int _tmain(int argc, _TCHAR* argv[])
{

	BiTree T;
	InitBiTree(T);
	CreateBiTree(T);
	//InOrderTraverse(T);
	
	LevelorderTraverse(T);
	return 0;
}

